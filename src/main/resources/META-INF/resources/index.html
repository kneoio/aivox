<!DOCTYPE html>
<html>
<head>
    <title>HLS Test Player</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: Arial, sans-serif; margin: 24px; }
        .row { margin: 12px 0; }
        input[type="text"] { width: min(900px, 100%); padding: 8px; }
        button { padding: 8px 12px; }
        #status { white-space: pre-wrap; margin-top: 12px; }
    </style>
</head>
<body>

<h1>HLS Test Player</h1>

<div class="row">
    <label for="station">Station:</label>
    <select id="station">
        <option value="lumisonic">lumisonic</option>
    </select>
    <button id="startStream" type="button">Start Stream</button>
    <button id="stopStream" type="button">Stop Stream</button>
</div>

<div id="streamStatus"></div>

<div class="row">
    <label for="src">HLS URL (.m3u8):</label>
</div>

<div class="row">
    <input id="src" type="text" spellcheck="false" />
    <button id="load" type="button">Load</button>
</div>

<div class="row">
    <audio id="audio" controls autoplay style="width: min(900px, 100%);"></audio>
</div>

<div id="status"></div>

<script src="https://cdn.jsdelivr.net/npm/hls.js@latest"></script>
<script>
    const audio = document.getElementById('audio');
    const srcInput = document.getElementById('src');
    const loadBtn = document.getElementById('load');
    const statusEl = document.getElementById('status');
    const stationSelect = document.getElementById('station');
    const startStreamBtn = document.getElementById('startStream');
    const stopStreamBtn = document.getElementById('stopStream');
    const streamStatusEl = document.getElementById('streamStatus');

    const params = new URLSearchParams(window.location.search);
    const defaultSrc = params.get('src') || 'http://localhost:38798/api/stream/lumisonic/stream.m3u8';
    srcInput.value = defaultSrc;

    function setStreamStatus(msg) {
        streamStatusEl.textContent = msg || '';
    }

    async function startStream() {
        const brand = stationSelect.value;
        setStreamStatus('Starting stream for ' + brand + '...');
        
        try {
            const response = await fetch('/api/debug/stream/' + brand, {
                method: 'POST'
            });
            
            if (response.ok) {
                const data = await response.json();
                setStreamStatus('Stream started: ' + JSON.stringify(data));
            } else {
                const error = await response.text();
                setStreamStatus('Error starting stream: ' + error);
            }
        } catch (err) {
            setStreamStatus('Error: ' + err.message);
        }
    }

    async function stopStream() {
        const brand = stationSelect.value;
        setStreamStatus('Stopping stream for ' + brand + '...');
        
        try {
            const response = await fetch('/api/debug/stream/' + brand, {
                method: 'DELETE'
            });
            
            if (response.ok) {
                const data = await response.json();
                setStreamStatus('Stream stopped: ' + JSON.stringify(data));
            } else {
                const error = await response.text();
                setStreamStatus('Error stopping stream: ' + error);
            }
        } catch (err) {
            setStreamStatus('Error: ' + err.message);
        }
    }

    startStreamBtn.addEventListener('click', startStream);
    stopStreamBtn.addEventListener('click', stopStream);

    let hls;
    let retryCount = 0;
    let maxRetries = 10;
    let retryDelay = 1000; // Start with 1 second
    let isServerDown = false;

    function setStatus(msg) {
        statusEl.textContent = msg || '';
    }

    function load(src) {
        setStatus('Loading: ' + src);
        retryCount = 0;
        retryDelay = 1000;
        isServerDown = false;

        if (hls) {
            hls.destroy();
            hls = undefined;
        }

        if (audio.canPlayType('application/vnd.apple.mpegurl')) {
            audio.src = src;
            audio.play().catch(() => {});
            setStatus('Using native HLS support');
            return;
        }

        if (window.Hls && window.Hls.isSupported()) {
            hls = new Hls({
                debug: true,
                enableWorker: true,
                manifestLoadingTimeOut: 10000,
                manifestLoadingMaxRetry: 3,
                manifestLoadingRetryDelay: 1000,
                levelLoadingTimeOut: 10000,
                levelLoadingMaxRetry: 4,
                levelLoadingRetryDelay: 1000,
                fragLoadingTimeOut: 20000,
                fragLoadingMaxRetry: 6,
                fragLoadingRetryDelay: 1000,
                xhrSetup: function(xhr, url) {
                    xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
                }
            });
            hls.loadSource(src);
            hls.attachMedia(audio);

            hls.on(Hls.Events.MANIFEST_PARSED, function (event, data) {
                setStatus('Manifest parsed. Levels: ' + data.levels.length);
                audio.play().catch(() => {});
            });

            hls.on(Hls.Events.LEVEL_LOADED, function (event, data) {
                console.log('Level loaded:', data);
            });

            hls.on(Hls.Events.FRAG_LOADED, function (event, data) {
                console.log('Fragment loaded:', data.frag.url);
            });

            hls.on(Hls.Events.ERROR, function (event, data) {
                const msg = 'Error: ' + data.type + ' / ' + data.details + 
                    (data.fatal ? ' (FATAL)' : '') +
                    (data.response ? '\nHTTP ' + data.response.code + ': ' + data.response.text : '') +
                    (data.url ? '\nURL: ' + data.url : '');
                setStatus(msg);
                console.error('HLS error:', data);
                
                // Detect server downtime
                if (data.response && (data.response.code === 0 || data.response.code >= 500)) {
                    isServerDown = true;
                } else if (data.type === Hls.ErrorTypes.NETWORK_ERROR && 
                          (data.details === Hls.ErrorDetails.FRAG_LOAD_ERROR || 
                           data.details === Hls.ErrorDetails.MANIFEST_LOAD_ERROR)) {
                    isServerDown = true;
                }
                
                if (data.fatal) {
                    switch(data.type) {
                        case Hls.ErrorTypes.NETWORK_ERROR:
                            if (isServerDown) {
                                handleServerError();
                            } else {
                                setStatus(msg + '\n\nRetrying...');
                                retryWithBackoff();
                            }
                            break;
                        case Hls.ErrorTypes.MEDIA_ERROR:
                            setStatus(msg + '\n\nRecovering...');
                            hls.recoverMediaError();
                            break;
                        default:
                            setStatus(msg + '\n\nCannot recover');
                            hls.destroy();
                            break;
                    }
                }
            });

            setStatus('Using hls.js');
            return;
        }

        function handleServerError() {
            if (retryCount >= maxRetries) {
                setStatus('Server appears to be down. Max retries reached. Stopping requests.\nClick "Load" to retry manually.');
                hls.destroy();
                return;
            }
            
            const delay = retryDelay * Math.pow(2, retryCount); // Exponential backoff
            setStatus(`Server appears to be down. Retrying in ${Math.round(delay/1000)}s... (Attempt ${retryCount + 1}/${maxRetries})`);
            
            setTimeout(() => {
                retryCount++;
                setStatus('Retrying connection to server...');
                hls.loadSource(srcInput.value);
                hls.startLoad();
            }, delay);
        }

        function retryWithBackoff() {
            if (retryCount >= maxRetries) {
                setStatus('Max retries reached. Stopping.\nClick "Load" to retry manually.');
                hls.destroy();
                return;
            }
            
            const delay = retryDelay * Math.pow(2, retryCount); // Exponential backoff
            setStatus(`Retrying in ${Math.round(delay/1000)}s... (Attempt ${retryCount + 1}/${maxRetries})`);
            
            setTimeout(() => {
                retryCount++;
                setStatus('Retrying...');
                hls.startLoad();
            }, delay);
        }

        setStatus('HLS is not supported in this browser');
    }

    loadBtn.addEventListener('click', () => load(srcInput.value));
    load(defaultSrc);
</script>
</body>
</html>